
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import exceptions.*;
import java_cup.runtime.*;
import java.io.*;
import nonterminal.*;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.ArrayList;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return Sym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\152\000\002\002\011\000\002\002\004\000\002\002" +
    "\013\000\002\003\006\000\002\004\004\000\002\004\002" +
    "\000\002\005\007\000\002\005\002\000\002\006\004\000" +
    "\002\006\002\000\002\007\007\000\002\007\002\000\002" +
    "\010\004\000\002\010\002\000\002\011\007\000\002\011" +
    "\002\000\002\012\005\000\002\012\002\000\002\013\005" +
    "\000\002\027\005\000\002\027\007\000\002\026\004\000" +
    "\002\026\005\000\002\030\004\000\002\030\003\000\002" +
    "\030\003\000\002\030\006\000\002\030\005\000\002\030" +
    "\005\000\002\031\005\000\002\031\002\000\002\032\005" +
    "\000\002\032\006\000\002\035\003\000\002\035\003\000" +
    "\002\035\003\000\002\035\003\000\002\035\003\000\002" +
    "\036\006\000\002\037\005\000\002\037\002\000\002\040" +
    "\005\000\002\040\002\000\002\041\006\000\002\042\004" +
    "\000\002\043\005\000\002\043\002\000\002\014\004\000" +
    "\002\015\005\000\002\015\002\000\002\016\003\000\002" +
    "\016\003\000\002\016\003\000\002\016\003\000\002\016" +
    "\002\000\002\017\010\000\002\053\002\000\002\020\012" +
    "\000\002\054\002\000\002\021\007\000\002\021\002\000" +
    "\002\022\004\000\002\022\002\000\002\023\003\000\002" +
    "\023\004\000\002\033\004\000\002\033\003\000\002\033" +
    "\003\000\002\033\006\000\002\033\005\000\002\033\005" +
    "\000\002\034\005\000\002\034\002\000\002\024\006\000" +
    "\002\045\003\000\002\045\005\000\002\055\003\000\002" +
    "\055\003\000\002\055\003\000\002\055\003\000\002\055" +
    "\003\000\002\055\003\000\002\046\005\000\002\025\003" +
    "\000\002\025\003\000\002\025\002\000\002\047\005\000" +
    "\002\047\005\000\002\047\005\000\002\047\002\000\002" +
    "\050\004\000\002\051\005\000\002\051\005\000\002\051" +
    "\005\000\002\051\005\000\002\051\004\000\002\051\002" +
    "\000\002\052\004\000\002\052\003\000\002\052\005\000" +
    "\002\052\004\000\002\052\004\000\002\052\002\000\002" +
    "\044\005\000\002\044\006\000\002\044\002" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\305\000\004\022\004\001\002\000\004\056\007\001" +
    "\002\000\004\002\006\001\002\000\004\002\000\001\002" +
    "\000\004\047\010\001\002\000\016\023\ufffc\024\ufffc\025" +
    "\011\026\ufffc\027\ufffc\041\ufffc\001\002\000\016\023\ufffa" +
    "\024\ufffa\026\ufffa\027\ufffa\041\ufffa\056\ufffa\001\002\000" +
    "\006\023\273\024\274\001\002\000\014\023\ufff8\024\ufff8" +
    "\026\015\027\ufff8\041\ufff8\001\002\000\012\023\ufff4\024" +
    "\ufff4\027\143\041\ufff4\001\002\000\014\023\ufff6\024\ufff6" +
    "\027\ufff6\041\ufff6\056\ufff6\001\002\000\014\023\ufff9\024" +
    "\ufff9\027\ufff9\041\ufff9\056\017\001\002\000\004\004\020" +
    "\001\002\000\014\030\022\031\030\042\021\043\027\056" +
    "\024\001\002\000\010\024\uffdd\045\uffdd\047\uffdd\001\002" +
    "\000\010\024\uffd7\047\uffd7\056\125\001\002\000\004\047" +
    "\123\001\002\000\010\024\uffe0\045\uffe0\047\uffe0\001\002" +
    "\000\010\024\uffdf\045\uffdf\047\uffdf\001\002\000\010\024" +
    "\uffde\045\uffde\047\uffde\001\002\000\010\024\uffdc\045\uffdc" +
    "\047\uffdc\001\002\000\046\004\uffac\005\uffac\006\uffac\007" +
    "\uffac\010\uffac\011\uffac\012\032\013\033\014\uffac\015\uffac" +
    "\016\uffac\017\uffac\020\uffac\021\uffac\032\uffac\044\uffac\055" +
    "\uffac\056\uffac\001\002\000\070\004\uff9b\005\uff9b\006\uff9b" +
    "\007\uff9b\010\uff9b\011\uff9b\012\uff9b\013\uff9b\014\uff9b\015" +
    "\uff9b\016\uff9b\017\uff9b\020\uff9b\021\050\024\uff9b\032\uff9b" +
    "\034\uff9b\036\uff9b\037\uff9b\040\uff9b\044\054\045\uff9b\047" +
    "\uff9b\051\uff9b\054\uff9b\055\055\056\053\001\002\000\070" +
    "\004\uffae\005\uffae\006\uffae\007\uffae\010\uffae\011\uffae\012" +
    "\uffae\013\uffae\014\uffae\015\uffae\016\uffae\017\uffae\020\uffae" +
    "\021\uffae\024\uffae\032\uffae\034\uffae\036\uffae\037\uffae\040" +
    "\uffae\044\uffae\045\uffae\047\uffae\051\uffae\054\uffae\055\uffae" +
    "\056\uffae\001\002\000\070\004\uffad\005\uffad\006\uffad\007" +
    "\uffad\010\uffad\011\uffad\012\uffad\013\uffad\014\uffad\015\uffad" +
    "\016\uffad\017\uffad\020\uffad\021\uffad\024\uffad\032\uffad\034" +
    "\uffad\036\uffad\037\uffad\040\uffad\044\uffad\045\uffad\047\uffad" +
    "\051\uffad\054\uffad\055\uffad\056\uffad\001\002\000\042\004" +
    "\043\005\044\006\045\007\041\010\046\011\042\024\uffb7" +
    "\032\uffb7\034\uffb7\036\uffb7\037\uffb7\040\uffb7\045\uffb7\047" +
    "\uffb7\051\uffb7\054\uffb7\001\002\000\004\032\036\001\002" +
    "\000\014\030\022\031\030\042\021\043\027\056\024\001" +
    "\002\000\010\024\uffd6\045\uffd6\047\uffd6\001\002\000\054" +
    "\012\032\013\033\014\uffac\015\uffac\016\uffac\017\uffac\020" +
    "\uffac\021\uffac\024\uffac\032\uffac\034\uffac\036\uffac\037\uffac" +
    "\040\uffac\044\uffac\045\uffac\047\uffac\051\uffac\054\uffac\055" +
    "\uffac\056\uffac\001\002\000\054\012\uffb2\013\uffb2\014\uffb2" +
    "\015\uffb2\016\uffb2\017\uffb2\020\uffb2\021\uffb2\024\uffb2\032" +
    "\uffb2\034\uffb2\036\uffb2\037\uffb2\040\uffb2\044\uffb2\045\uffb2" +
    "\047\uffb2\051\uffb2\054\uffb2\055\uffb2\056\uffb2\001\002\000" +
    "\054\012\uffb0\013\uffb0\014\uffb0\015\uffb0\016\uffb0\017\uffb0" +
    "\020\uffb0\021\uffb0\024\uffb0\032\uffb0\034\uffb0\036\uffb0\037" +
    "\uffb0\040\uffb0\044\uffb0\045\uffb0\047\uffb0\051\uffb0\054\uffb0" +
    "\055\uffb0\056\uffb0\001\002\000\054\012\uffb5\013\uffb5\014" +
    "\uffb5\015\uffb5\016\uffb5\017\uffb5\020\uffb5\021\uffb5\024\uffb5" +
    "\032\uffb5\034\uffb5\036\uffb5\037\uffb5\040\uffb5\044\uffb5\045" +
    "\uffb5\047\uffb5\051\uffb5\054\uffb5\055\uffb5\056\uffb5\001\002" +
    "\000\054\012\uffb4\013\uffb4\014\uffb4\015\uffb4\016\uffb4\017" +
    "\uffb4\020\uffb4\021\uffb4\024\uffb4\032\uffb4\034\uffb4\036\uffb4" +
    "\037\uffb4\040\uffb4\044\uffb4\045\uffb4\047\uffb4\051\uffb4\054" +
    "\uffb4\055\uffb4\056\uffb4\001\002\000\054\012\uffb3\013\uffb3" +
    "\014\uffb3\015\uffb3\016\uffb3\017\uffb3\020\uffb3\021\uffb3\024" +
    "\uffb3\032\uffb3\034\uffb3\036\uffb3\037\uffb3\040\uffb3\044\uffb3" +
    "\045\uffb3\047\uffb3\051\uffb3\054\uffb3\055\uffb3\056\uffb3\001" +
    "\002\000\054\012\uffb1\013\uffb1\014\uffb1\015\uffb1\016\uffb1" +
    "\017\uffb1\020\uffb1\021\uffb1\024\uffb1\032\uffb1\034\uffb1\036" +
    "\uffb1\037\uffb1\040\uffb1\044\uffb1\045\uffb1\047\uffb1\051\uffb1" +
    "\054\uffb1\055\uffb1\056\uffb1\001\002\000\026\024\uffb6\032" +
    "\uffb6\034\uffb6\036\uffb6\037\uffb6\040\uffb6\045\uffb6\047\uffb6" +
    "\051\uffb6\054\uffb6\001\002\000\070\004\uff9b\005\uff9b\006" +
    "\uff9b\007\uff9b\010\uff9b\011\uff9b\012\uff9b\013\uff9b\014\uff9b" +
    "\015\uff9b\016\uff9b\017\uff9b\020\uff9b\021\050\024\uff9b\032" +
    "\uff9b\034\uff9b\036\uff9b\037\uff9b\040\uff9b\044\054\045\uff9b" +
    "\047\uff9b\051\uff9b\054\uff9b\055\055\056\053\001\002\000" +
    "\070\004\uffa1\005\uffa1\006\uffa1\007\uffa1\010\uffa1\011\uffa1" +
    "\012\uffa1\013\uffa1\014\uffa1\015\110\016\106\017\104\020" +
    "\103\021\050\024\uffa1\032\uffa1\034\uffa1\036\uffa1\037\uffa1" +
    "\040\uffa1\044\054\045\uffa1\047\uffa1\051\uffa1\054\uffa1\055" +
    "\055\056\053\001\002\000\050\004\uffa8\005\uffa8\006\uffa8" +
    "\007\uffa8\010\uffa8\011\uffa8\012\071\013\073\014\074\024" +
    "\uffa8\032\uffa8\034\uffa8\036\uffa8\037\uffa8\040\uffa8\045\uffa8" +
    "\047\uffa8\051\uffa8\054\uffa8\001\002\000\074\004\uff98\005" +
    "\uff98\006\uff98\007\uff98\010\uff98\011\uff98\012\uff98\013\uff98" +
    "\014\uff98\015\uff98\016\uff98\017\uff98\020\uff98\021\uff98\024" +
    "\uff98\032\uff98\034\uff98\036\uff98\037\uff98\040\uff98\044\uff98" +
    "\045\uff98\046\063\047\uff98\051\uff98\053\062\054\uff98\055" +
    "\uff98\056\uff98\001\002\000\046\004\uffac\005\uffac\006\uffac" +
    "\007\uffac\010\uffac\011\uffac\012\032\013\033\014\uffac\015" +
    "\uffac\016\uffac\017\uffac\020\uffac\021\uffac\044\uffac\045\057" +
    "\055\uffac\056\uffac\001\002\000\070\004\uff9f\005\uff9f\006" +
    "\uff9f\007\uff9f\010\uff9f\011\uff9f\012\uff9f\013\uff9f\014\uff9f" +
    "\015\uff9f\016\uff9f\017\uff9f\020\uff9f\021\uff9f\024\uff9f\032" +
    "\uff9f\034\uff9f\036\uff9f\037\uff9f\040\uff9f\044\uff9f\045\uff9f" +
    "\047\uff9f\051\uff9f\054\uff9f\055\uff9f\056\uff9f\001\002\000" +
    "\004\045\060\001\002\000\070\004\uff9d\005\uff9d\006\uff9d" +
    "\007\uff9d\010\uff9d\011\uff9d\012\uff9d\013\uff9d\014\uff9d\015" +
    "\uff9d\016\uff9d\017\uff9d\020\uff9d\021\uff9d\024\uff9d\032\uff9d" +
    "\034\uff9d\036\uff9d\037\uff9d\040\uff9d\044\uff9d\045\uff9d\047" +
    "\uff9d\051\uff9d\054\uff9d\055\uff9d\056\uff9d\001\002\000\070" +
    "\004\uff9e\005\uff9e\006\uff9e\007\uff9e\010\uff9e\011\uff9e\012" +
    "\uff9e\013\uff9e\014\uff9e\015\uff9e\016\uff9e\017\uff9e\020\uff9e" +
    "\021\uff9e\024\uff9e\032\uff9e\034\uff9e\036\uff9e\037\uff9e\040" +
    "\uff9e\044\uff9e\045\uff9e\047\uff9e\051\uff9e\054\uff9e\055\uff9e" +
    "\056\uff9e\001\002\000\070\004\uffa0\005\uffa0\006\uffa0\007" +
    "\uffa0\010\uffa0\011\uffa0\012\uffa0\013\uffa0\014\uffa0\015\uffa0" +
    "\016\uffa0\017\uffa0\020\uffa0\021\uffa0\024\uffa0\032\uffa0\034" +
    "\uffa0\036\uffa0\037\uffa0\040\uffa0\044\uffa0\045\uffa0\047\uffa0" +
    "\051\uffa0\054\uffa0\055\uffa0\056\uffa0\001\002\000\046\004" +
    "\uffac\005\uffac\006\uffac\007\uffac\010\uffac\011\uffac\012\032" +
    "\013\033\014\uffac\015\uffac\016\uffac\017\uffac\020\uffac\021" +
    "\uffac\044\uffac\054\uffac\055\uffac\056\uffac\001\002\000\004" +
    "\056\064\001\002\000\076\004\uff98\005\uff98\006\uff98\007" +
    "\uff98\010\uff98\011\uff98\012\uff98\013\uff98\014\uff98\015\uff98" +
    "\016\uff98\017\uff98\020\uff98\021\uff98\024\uff98\032\uff98\034" +
    "\uff98\036\uff98\037\uff98\040\uff98\044\uff98\045\uff98\046\063" +
    "\047\uff98\051\uff98\052\uff98\053\062\054\uff98\055\uff98\056" +
    "\uff98\001\002\000\072\004\uff9a\005\uff9a\006\uff9a\007\uff9a" +
    "\010\uff9a\011\uff9a\012\uff9a\013\uff9a\014\uff9a\015\uff9a\016" +
    "\uff9a\017\uff9a\020\uff9a\021\uff9a\024\uff9a\032\uff9a\034\uff9a" +
    "\036\uff9a\037\uff9a\040\uff9a\044\uff9a\045\uff9a\047\uff9a\051" +
    "\uff9a\052\uff9a\054\uff9a\055\uff9a\056\uff9a\001\002\000\004" +
    "\054\067\001\002\000\076\004\uff98\005\uff98\006\uff98\007" +
    "\uff98\010\uff98\011\uff98\012\uff98\013\uff98\014\uff98\015\uff98" +
    "\016\uff98\017\uff98\020\uff98\021\uff98\024\uff98\032\uff98\034" +
    "\uff98\036\uff98\037\uff98\040\uff98\044\uff98\045\uff98\046\063" +
    "\047\uff98\051\uff98\052\uff98\053\062\054\uff98\055\uff98\056" +
    "\uff98\001\002\000\072\004\uff99\005\uff99\006\uff99\007\uff99" +
    "\010\uff99\011\uff99\012\uff99\013\uff99\014\uff99\015\uff99\016" +
    "\uff99\017\uff99\020\uff99\021\uff99\024\uff99\032\uff99\034\uff99" +
    "\036\uff99\037\uff99\040\uff99\044\uff99\045\uff99\047\uff99\051" +
    "\uff99\052\uff99\054\uff99\055\uff99\056\uff99\001\002\000\046" +
    "\004\uff9b\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b\012" +
    "\uff9b\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b\020\uff9b" +
    "\021\050\032\uff9b\044\054\055\055\056\053\001\002\000" +
    "\042\004\uffaf\005\uffaf\006\uffaf\007\uffaf\010\uffaf\011\uffaf" +
    "\024\uffaf\032\uffaf\034\uffaf\036\uffaf\037\uffaf\040\uffaf\045" +
    "\uffaf\047\uffaf\051\uffaf\054\uffaf\001\002\000\046\004\uff9b" +
    "\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b\012\uff9b\013" +
    "\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b\020\uff9b\021\050" +
    "\032\uff9b\044\054\055\055\056\053\001\002\000\046\004" +
    "\uff9b\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b\012\uff9b" +
    "\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b\020\uff9b\021" +
    "\050\032\uff9b\044\054\055\055\056\053\001\002\000\050" +
    "\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011\uffa8\012" +
    "\071\013\073\014\074\024\uffa8\032\uffa8\034\uffa8\036\uffa8" +
    "\037\uffa8\040\uffa8\045\uffa8\047\uffa8\051\uffa8\054\uffa8\001" +
    "\002\000\042\004\uffa9\005\uffa9\006\uffa9\007\uffa9\010\uffa9" +
    "\011\uffa9\024\uffa9\032\uffa9\034\uffa9\036\uffa9\037\uffa9\040" +
    "\uffa9\045\uffa9\047\uffa9\051\uffa9\054\uffa9\001\002\000\050" +
    "\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011\uffa8\012" +
    "\071\013\073\014\074\024\uffa8\032\uffa8\034\uffa8\036\uffa8" +
    "\037\uffa8\040\uffa8\045\uffa8\047\uffa8\051\uffa8\054\uffa8\001" +
    "\002\000\042\004\uffaa\005\uffaa\006\uffaa\007\uffaa\010\uffaa" +
    "\011\uffaa\024\uffaa\032\uffaa\034\uffaa\036\uffaa\037\uffaa\040" +
    "\uffaa\045\uffaa\047\uffaa\051\uffaa\054\uffaa\001\002\000\050" +
    "\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011\uffa8\012" +
    "\071\013\073\014\074\024\uffa8\032\uffa8\034\uffa8\036\uffa8" +
    "\037\uffa8\040\uffa8\045\uffa8\047\uffa8\051\uffa8\054\uffa8\001" +
    "\002\000\042\004\uffab\005\uffab\006\uffab\007\uffab\010\uffab" +
    "\011\uffab\024\uffab\032\uffab\034\uffab\036\uffab\037\uffab\040" +
    "\uffab\045\uffab\047\uffab\051\uffab\054\uffab\001\002\000\070" +
    "\004\uff9b\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b\012" +
    "\uff9b\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b\020\uff9b" +
    "\021\050\024\uff9b\032\uff9b\034\uff9b\036\uff9b\037\uff9b\040" +
    "\uff9b\044\054\045\uff9b\047\uff9b\051\uff9b\054\uff9b\055\055" +
    "\056\053\001\002\000\070\004\uff9b\005\uff9b\006\uff9b\007" +
    "\uff9b\010\uff9b\011\uff9b\012\uff9b\013\uff9b\014\uff9b\015\uff9b" +
    "\016\uff9b\017\uff9b\020\uff9b\021\050\024\uff9b\032\uff9b\034" +
    "\uff9b\036\uff9b\037\uff9b\040\uff9b\044\054\045\uff9b\047\uff9b" +
    "\051\uff9b\054\uff9b\055\055\056\053\001\002\000\050\004" +
    "\uffa7\005\uffa7\006\uffa7\007\uffa7\010\uffa7\011\uffa7\012\uffa7" +
    "\013\uffa7\014\uffa7\024\uffa7\032\uffa7\034\uffa7\036\uffa7\037" +
    "\uffa7\040\uffa7\045\uffa7\047\uffa7\051\uffa7\054\uffa7\001\002" +
    "\000\070\004\uff9b\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011" +
    "\uff9b\012\uff9b\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b" +
    "\020\uff9b\021\050\024\uff9b\032\uff9b\034\uff9b\036\uff9b\037" +
    "\uff9b\040\uff9b\044\054\045\uff9b\047\uff9b\051\uff9b\054\uff9b" +
    "\055\055\056\053\001\002\000\070\004\uffa1\005\uffa1\006" +
    "\uffa1\007\uffa1\010\uffa1\011\uffa1\012\uffa1\013\uffa1\014\uffa1" +
    "\015\110\016\106\017\104\020\103\021\050\024\uffa1\032" +
    "\uffa1\034\uffa1\036\uffa1\037\uffa1\040\uffa1\044\054\045\uffa1" +
    "\047\uffa1\051\uffa1\054\uffa1\055\055\056\053\001\002\000" +
    "\070\004\uff9b\005\uff9b\006\uff9b\007\uff9b\010\uff9b\011\uff9b" +
    "\012\uff9b\013\uff9b\014\uff9b\015\uff9b\016\uff9b\017\uff9b\020" +
    "\uff9b\021\050\024\uff9b\032\uff9b\034\uff9b\036\uff9b\037\uff9b" +
    "\040\uff9b\044\054\045\uff9b\047\uff9b\051\uff9b\054\uff9b\055" +
    "\055\056\053\001\002\000\070\004\uffa1\005\uffa1\006\uffa1" +
    "\007\uffa1\010\uffa1\011\uffa1\012\uffa1\013\uffa1\014\uffa1\015" +
    "\110\016\106\017\104\020\103\021\050\024\uffa1\032\uffa1" +
    "\034\uffa1\036\uffa1\037\uffa1\040\uffa1\044\054\045\uffa1\047" +
    "\uffa1\051\uffa1\054\uffa1\055\055\056\053\001\002\000\050" +
    "\004\uffa6\005\uffa6\006\uffa6\007\uffa6\010\uffa6\011\uffa6\012" +
    "\uffa6\013\uffa6\014\uffa6\024\uffa6\032\uffa6\034\uffa6\036\uffa6" +
    "\037\uffa6\040\uffa6\045\uffa6\047\uffa6\051\uffa6\054\uffa6\001" +
    "\002\000\050\004\uffa2\005\uffa2\006\uffa2\007\uffa2\010\uffa2" +
    "\011\uffa2\012\uffa2\013\uffa2\014\uffa2\024\uffa2\032\uffa2\034" +
    "\uffa2\036\uffa2\037\uffa2\040\uffa2\045\uffa2\047\uffa2\051\uffa2" +
    "\054\uffa2\001\002\000\070\004\uffa1\005\uffa1\006\uffa1\007" +
    "\uffa1\010\uffa1\011\uffa1\012\uffa1\013\uffa1\014\uffa1\015\110" +
    "\016\106\017\104\020\103\021\050\024\uffa1\032\uffa1\034" +
    "\uffa1\036\uffa1\037\uffa1\040\uffa1\044\054\045\uffa1\047\uffa1" +
    "\051\uffa1\054\uffa1\055\055\056\053\001\002\000\050\004" +
    "\uffa5\005\uffa5\006\uffa5\007\uffa5\010\uffa5\011\uffa5\012\uffa5" +
    "\013\uffa5\014\uffa5\024\uffa5\032\uffa5\034\uffa5\036\uffa5\037" +
    "\uffa5\040\uffa5\045\uffa5\047\uffa5\051\uffa5\054\uffa5\001\002" +
    "\000\070\004\uffa1\005\uffa1\006\uffa1\007\uffa1\010\uffa1\011" +
    "\uffa1\012\uffa1\013\uffa1\014\uffa1\015\110\016\106\017\104" +
    "\020\103\021\050\024\uffa1\032\uffa1\034\uffa1\036\uffa1\037" +
    "\uffa1\040\uffa1\044\054\045\uffa1\047\uffa1\051\uffa1\054\uffa1" +
    "\055\055\056\053\001\002\000\050\004\uffa4\005\uffa4\006" +
    "\uffa4\007\uffa4\010\uffa4\011\uffa4\012\uffa4\013\uffa4\014\uffa4" +
    "\024\uffa4\032\uffa4\034\uffa4\036\uffa4\037\uffa4\040\uffa4\045" +
    "\uffa4\047\uffa4\051\uffa4\054\uffa4\001\002\000\070\004\uffa1" +
    "\005\uffa1\006\uffa1\007\uffa1\010\uffa1\011\uffa1\012\uffa1\013" +
    "\uffa1\014\uffa1\015\110\016\106\017\104\020\103\021\050" +
    "\024\uffa1\032\uffa1\034\uffa1\036\uffa1\037\uffa1\040\uffa1\044" +
    "\054\045\uffa1\047\uffa1\051\uffa1\054\uffa1\055\055\056\053" +
    "\001\002\000\050\004\uffa3\005\uffa3\006\uffa3\007\uffa3\010" +
    "\uffa3\011\uffa3\012\uffa3\013\uffa3\014\uffa3\024\uffa3\032\uffa3" +
    "\034\uffa3\036\uffa3\037\uffa3\040\uffa3\045\uffa3\047\uffa3\051" +
    "\uffa3\054\uffa3\001\002\000\070\004\uff9c\005\uff9c\006\uff9c" +
    "\007\uff9c\010\uff9c\011\uff9c\012\uff9c\013\uff9c\014\uff9c\015" +
    "\uff9c\016\uff9c\017\uff9c\020\uff9c\021\uff9c\024\uff9c\032\uff9c" +
    "\034\uff9c\036\uff9c\037\uff9c\040\uff9c\044\uff9c\045\uff9c\047" +
    "\uff9c\051\uff9c\054\uff9c\055\uff9c\056\uff9c\001\002\000\014" +
    "\023\ufff7\024\ufff7\027\ufff7\041\ufff7\056\ufff7\001\002\000" +
    "\004\050\140\001\002\000\006\050\uffd3\051\134\001\002" +
    "\000\006\024\uffd9\047\130\001\002\000\004\024\133\001" +
    "\002\000\010\024\uffd7\047\uffd7\056\125\001\002\000\006" +
    "\024\uffd9\047\130\001\002\000\004\024\uffda\001\002\000" +
    "\010\024\uffdb\045\uffdb\047\uffdb\001\002\000\004\056\136" +
    "\001\002\000\004\050\uffd5\001\002\000\006\050\uffd3\051" +
    "\134\001\002\000\004\050\uffd4\001\002\000\014\030\022" +
    "\031\030\042\021\043\027\056\024\001\002\000\006\024" +
    "\uffd8\047\uffd8\001\002\000\010\023\ufff0\024\ufff0\041\ufff0" +
    "\001\002\000\012\023\ufff2\024\ufff2\041\ufff2\056\ufff2\001" +
    "\002\000\012\023\ufff5\024\ufff5\041\ufff5\056\125\001\002" +
    "\000\004\050\146\001\002\000\014\030\022\031\030\042" +
    "\021\043\027\056\024\001\002\000\004\047\150\001\002" +
    "\000\012\023\ufff3\024\ufff3\041\ufff3\056\ufff3\001\002\000" +
    "\010\023\ufffe\024\ufffe\041\152\001\002\000\004\056\246" +
    "\001\002\000\004\047\245\001\002\000\004\047\155\001" +
    "\002\000\016\023\ufffc\024\ufffc\025\011\026\ufffc\027\ufffc" +
    "\041\ufffc\001\002\000\006\023\160\024\161\001\002\000" +
    "\004\047\uffef\001\002\000\014\024\uffcb\033\163\035\165" +
    "\047\uffcb\056\167\001\002\000\004\056\162\001\002\000" +
    "\004\047\uffee\001\002\000\046\004\uffc9\005\uffc9\006\uffc9" +
    "\007\uffc9\010\uffc9\011\uffc9\012\uffc9\013\uffc9\014\uffc9\015" +
    "\uffc9\016\uffc9\017\uffc9\020\uffc9\021\uffc9\034\uffc9\044\uffc9" +
    "\055\uffc9\056\uffc9\001\002\000\012\024\uffcf\037\uffcf\040" +
    "\uffcf\047\uffcf\001\002\000\046\004\uffc7\005\uffc7\006\uffc7" +
    "\007\uffc7\010\uffc7\011\uffc7\012\uffc7\013\uffc7\014\uffc7\015" +
    "\uffc7\016\uffc7\017\uffc7\020\uffc7\021\uffc7\036\uffc7\044\uffc7" +
    "\055\uffc7\056\uffc7\001\002\000\012\024\uffd0\037\uffd0\040" +
    "\uffd0\047\217\001\002\000\066\004\uffac\005\uffac\006\uffac" +
    "\007\uffac\010\uffac\011\uffac\012\032\013\033\014\uffac\015" +
    "\uffac\016\uffac\017\uffac\020\uffac\021\uffac\024\uffc2\037\uffc2" +
    "\040\uffc2\044\176\045\201\046\063\047\uffc2\051\uffac\052" +
    "\uff98\053\062\055\uffac\056\uffac\001\002\000\012\024\uffce" +
    "\037\uffce\040\uffce\047\uffce\001\002\000\012\024\uffcc\037" +
    "\uffcc\040\uffcc\047\uffcc\001\002\000\012\024\uffcd\037\uffcd" +
    "\040\uffcd\047\uffcd\001\002\000\004\024\174\001\002\000" +
    "\004\056\175\001\002\000\004\047\uffed\001\002\000\060" +
    "\004\uffac\005\uffac\006\uffac\007\uffac\010\uffac\011\uffac\012" +
    "\032\013\033\014\uffac\015\uffac\016\uffac\017\uffac\020\uffac" +
    "\021\uffac\024\uffbf\037\uffbf\040\uffbf\044\uffac\045\213\047" +
    "\uffbf\051\uffac\055\uffac\056\uffac\001\002\000\004\052\210" +
    "\001\002\000\006\045\uffb9\051\203\001\002\000\012\024" +
    "\uffbe\037\uffbe\040\uffbe\047\uffbe\001\002\000\012\024\uffc1" +
    "\037\uffc1\040\uffc1\047\uffc1\001\002\000\060\004\uffac\005" +
    "\uffac\006\uffac\007\uffac\010\uffac\011\uffac\012\032\013\033" +
    "\014\uffac\015\uffac\016\uffac\017\uffac\020\uffac\021\uffac\024" +
    "\uffac\037\uffac\040\uffac\044\uffac\045\uffac\047\uffac\051\uffac" +
    "\055\uffac\056\uffac\001\002\000\004\045\205\001\002\000" +
    "\012\024\uffbb\037\uffbb\040\uffbb\047\uffbb\001\002\000\016" +
    "\024\uffb9\037\uffb9\040\uffb9\045\uffb9\047\uffb9\051\203\001" +
    "\002\000\014\024\uffba\037\uffba\040\uffba\045\uffba\047\uffba" +
    "\001\002\000\054\004\uffac\005\uffac\006\uffac\007\uffac\010" +
    "\uffac\011\uffac\012\032\013\033\014\uffac\015\uffac\016\uffac" +
    "\017\uffac\020\uffac\021\uffac\024\uffac\037\uffac\040\uffac\044" +
    "\uffac\047\uffac\055\uffac\056\uffac\001\002\000\012\024\uffb8" +
    "\037\uffb8\040\uffb8\047\uffb8\001\002\000\016\024\uffb9\037" +
    "\uffb9\040\uffb9\045\uffb9\047\uffb9\051\203\001\002\000\012" +
    "\024\uffc0\037\uffc0\040\uffc0\047\uffc0\001\002\000\014\024" +
    "\uffbc\037\uffbc\040\uffbc\045\215\047\uffbc\001\002\000\012" +
    "\024\uffbd\037\uffbd\040\uffbd\047\uffbd\001\002\000\010\024" +
    "\uffd2\037\uffd2\040\uffd2\001\002\000\020\024\uffcb\033\163" +
    "\035\165\037\uffcb\040\uffcb\047\uffcb\056\167\001\002\000" +
    "\012\024\uffd0\037\uffd0\040\uffd0\047\217\001\002\000\010" +
    "\024\uffd1\037\uffd1\040\uffd1\001\002\000\046\004\uffac\005" +
    "\uffac\006\uffac\007\uffac\010\uffac\011\uffac\012\032\013\033" +
    "\014\uffac\015\uffac\016\uffac\017\uffac\020\uffac\021\uffac\036" +
    "\uffac\044\uffac\055\uffac\056\uffac\001\002\000\004\036\224" +
    "\001\002\000\020\024\uffcb\033\163\035\165\037\uffcb\040" +
    "\uffcb\047\uffcb\056\167\001\002\000\010\024\uffc5\037\227" +
    "\040\uffc5\001\002\000\006\024\uffc3\040\234\001\002\000" +
    "\046\004\uffac\005\uffac\006\uffac\007\uffac\010\uffac\011\uffac" +
    "\012\032\013\033\014\uffac\015\uffac\016\uffac\017\uffac\020" +
    "\uffac\021\uffac\036\uffac\044\uffac\055\uffac\056\uffac\001\002" +
    "\000\004\036\231\001\002\000\020\024\uffcb\033\163\035" +
    "\165\037\uffcb\040\uffcb\047\uffcb\056\167\001\002\000\010" +
    "\024\uffc5\037\227\040\uffc5\001\002\000\006\024\uffc6\040" +
    "\uffc6\001\002\000\014\024\uffcb\033\163\035\165\047\uffcb" +
    "\056\167\001\002\000\004\024\236\001\002\000\012\024" +
    "\uffc8\037\uffc8\040\uffc8\047\uffc8\001\002\000\004\024\uffc4" +
    "\001\002\000\046\004\uffac\005\uffac\006\uffac\007\uffac\010" +
    "\uffac\011\uffac\012\032\013\033\014\uffac\015\uffac\016\uffac" +
    "\017\uffac\020\uffac\021\uffac\034\uffac\044\uffac\055\uffac\056" +
    "\uffac\001\002\000\004\034\242\001\002\000\014\024\uffcb" +
    "\033\163\035\165\047\uffcb\056\167\001\002\000\004\024" +
    "\244\001\002\000\012\024\uffca\037\uffca\040\uffca\047\uffca" +
    "\001\002\000\010\023\ufff1\024\ufff1\041\ufff1\001\002\000" +
    "\014\027\247\044\253\045\254\047\uffec\056\125\001\002" +
    "\000\004\056\125\001\002\000\004\047\uffeb\001\002\000" +
    "\006\045\uffe3\047\257\001\002\000\004\050\264\001\002" +
    "\000\012\027\247\045\256\047\uffe9\056\125\001\002\000" +
    "\004\047\uffe8\001\002\000\006\045\uffe3\047\257\001\002" +
    "\000\004\047\uffea\001\002\000\006\027\247\056\125\001" +
    "\002\000\006\045\261\047\uffe6\001\002\000\004\047\uffe7" +
    "\001\002\000\006\045\uffe3\047\257\001\002\000\006\045" +
    "\uffe4\047\uffe4\001\002\000\014\030\022\031\030\042\021" +
    "\043\027\056\024\001\002\000\006\045\uffe2\047\uffe2\001" +
    "\002\000\004\045\267\001\002\000\004\047\uffe5\001\002" +
    "\000\004\050\271\001\002\000\014\030\022\031\030\042" +
    "\021\043\027\056\024\001\002\000\006\045\uffe1\047\uffe1" +
    "\001\002\000\014\024\uffcb\033\163\035\165\047\uffcb\056" +
    "\167\001\002\000\004\056\275\001\002\000\004\046\276" +
    "\001\002\000\004\002\001\001\002\000\004\024\300\001" +
    "\002\000\004\056\301\001\002\000\004\046\302\001\002" +
    "\000\004\002\uffff\001\002\000\016\023\ufffd\024\ufffd\026" +
    "\ufffd\027\ufffd\041\ufffd\056\304\001\002\000\004\004\305" +
    "\001\002\000\046\004\uffac\005\uffac\006\uffac\007\uffac\010" +
    "\uffac\011\uffac\012\032\013\033\014\uffac\015\uffac\016\uffac" +
    "\017\uffac\020\uffac\021\uffac\044\uffac\047\uffac\055\uffac\056" +
    "\uffac\001\002\000\004\047\307\001\002\000\016\023\ufffb" +
    "\024\ufffb\026\ufffb\027\ufffb\041\ufffb\056\ufffb\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\305\000\004\002\004\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\003\011\004\012\001\001\000\004\005\302\001\001\000" +
    "\002\001\001\000\004\006\013\001\001\000\004\010\141" +
    "\001\001\000\004\007\015\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\035\022\036\025\041\024\001\001" +
    "\000\002\001\001\000\006\040\125\042\123\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\025\030\045\034\046" +
    "\033\001\001\000\006\050\051\052\050\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\055\037\001\001\000" +
    "\002\001\001\000\010\035\036\036\025\041\024\001\001" +
    "\000\002\001\001\000\006\025\030\046\046\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\052\121\001\001\000\006\051\104\052\106" +
    "\001\001\000\004\047\071\001\001\000\004\044\060\001" +
    "\001\000\010\025\030\045\055\046\033\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\025\030\045\065\046\033" +
    "\001\001\000\002\001\001\000\004\044\064\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\044\067\001\001" +
    "\000\002\001\001\000\006\050\100\052\050\001\001\000" +
    "\002\001\001\000\006\050\076\052\050\001\001\000\006" +
    "\050\074\052\050\001\001\000\004\047\075\001\001\000" +
    "\002\001\001\000\004\047\077\001\001\000\002\001\001" +
    "\000\004\047\101\001\001\000\002\001\001\000\004\052" +
    "\117\001\001\000\004\052\115\001\001\000\002\001\001" +
    "\000\004\052\113\001\001\000\006\051\112\052\106\001" +
    "\001\000\004\052\110\001\001\000\006\051\111\052\106" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\051" +
    "\114\052\106\001\001\000\002\001\001\000\006\051\116" +
    "\052\106\001\001\000\002\001\001\000\006\051\120\052" +
    "\106\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\043\134\001\001\000" +
    "\004\037\126\001\001\000\002\001\001\000\006\040\130" +
    "\042\123\001\001\000\004\037\131\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\043\136\001\001\000\002\001\001\000\010\035" +
    "\140\036\025\041\024\001\001\000\002\001\001\000\004" +
    "\012\150\001\001\000\004\011\143\001\001\000\004\042" +
    "\144\001\001\000\002\001\001\000\010\035\146\036\025" +
    "\041\024\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\013\152\026\153\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\003\155\004\012\027" +
    "\156\001\001\000\002\001\001\000\002\001\001\000\016" +
    "\014\172\016\165\017\170\020\171\023\167\024\163\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\053\237" +
    "\001\001\000\002\001\001\000\004\054\221\001\001\000" +
    "\004\015\215\001\001\000\014\025\030\033\201\044\176" +
    "\045\177\046\033\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\025\030\045\211\046\033\001" +
    "\001\000\002\001\001\000\004\034\203\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\025\030\045\205\046" +
    "\033\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\034\206\001\001\000\002\001\001\000\010\025\030\045" +
    "\210\046\033\001\001\000\002\001\001\000\004\034\213" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\016\217\017\170\020\171" +
    "\023\167\024\163\001\001\000\004\015\220\001\001\000" +
    "\002\001\001\000\010\025\030\045\222\046\033\001\001" +
    "\000\002\001\001\000\016\014\224\016\165\017\170\020" +
    "\171\023\167\024\163\001\001\000\004\021\225\001\001" +
    "\000\004\022\234\001\001\000\010\025\030\045\227\046" +
    "\033\001\001\000\002\001\001\000\016\014\231\016\165" +
    "\017\170\020\171\023\167\024\163\001\001\000\004\021" +
    "\232\001\001\000\002\001\001\000\016\014\236\016\165" +
    "\017\170\020\171\023\167\024\163\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\025\030" +
    "\045\240\046\033\001\001\000\002\001\001\000\016\014" +
    "\242\016\165\017\170\020\171\023\167\024\163\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\030\247\032\250\042\251\001\001\000\004\042\267" +
    "\001\001\000\002\001\001\000\004\031\265\001\001\000" +
    "\002\001\001\000\006\032\254\042\251\001\001\000\002" +
    "\001\001\000\004\031\257\001\001\000\002\001\001\000" +
    "\006\032\261\042\251\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\031\262\001\001\000\002\001\001\000" +
    "\010\035\264\036\025\041\024\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\035\271\036\025\041\024\001\001\000\002\001\001" +
    "\000\016\014\276\016\165\017\170\020\171\023\167\024" +
    "\163\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\010\025\030\045\305\046\033\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

    if_level = 0;
    while_level = 0;
    symbol_list = new ArrayList<HashMap<String,Type>>();
    HashMap<String,Type> base = new HashMap<String,Type>();
    symbol_list.add(base);
    top = 0;
    res = 0;

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 
    return getScanner().next_token(); 

    }


    List<HashMap<String,Type>> symbol_list;
    int if_level;
    int while_level;
    int top;

    int res;
    String get_res(){
        return Integer.toString(res);
    }
    public boolean check_type(Type a, Type b) {
		if(a.type.size()!=b.type.size()) {
			return false;
		}
		for(int i = 0;i<a.type.size();i++) {
			String t1 = a.type.get(i);
			String t2 = b.type.get(i);
			if(!t1.equalsIgnoreCase(t2)) return false;
		}        
		if(a.left==true && b.left==false) return false;

		if(a.type.get(1).equalsIgnoreCase("array")) {
			return check_type(a.arr_type,b.arr_type);
		}
		else if(a.type.get(1).equalsIgnoreCase("record")) {
			HashMap<String,Type> map1 = a.symbol_list;
			HashMap<String,Type> map2 = b.symbol_list;
			if(map1.size()!=map2.size()) {
				return false;
			}
			Set<String> key = map1.keySet();
			for(String s:key) {
				Type t1 = map1.get(s);
				if(!map2.containsKey(s)) return false;
				Type t2 = map2.get(s);
				if(!check_type(t1,t2)) return false;
			}
		}
		return true;
	}
    public Type select_field(Type type,String select) throws Exception{
		Type pre = type;
		String iden = "";
		for(int i = 0;i<select.length();i++) {
			if(select.charAt(i)=='.') {
				i++;
				while(i<select.length()&&select.charAt(i)!='.'&&select.charAt(i)!='[') {
					iden+=select.charAt(i);
					i++;
				}
				i--;
				if(pre.type.size()>1&&pre.type.get(1).equalsIgnoreCase("record")&&pre.symbol_list.containsKey(iden)) {
					pre = pre.symbol_list.get(iden);
					iden = "";
				}
				else {
					throw new SemanticException("Identifier hasn't been declared");
				}
			}
			else if(select.charAt(i)=='[') {
				i++;
				while(i<select.length()&&select.charAt(i)!=']') {
					i++;
				}
				if(pre.type.size()>1&&pre.type.get(1).equalsIgnoreCase("array")) {
					pre = pre.arr_type;
				}
				else {
					return null;
				}
			}
		}
		return pre;
	}


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // module ::= MODULE IDENTIFIER SEMI declarations END IDENTIFIER DOT 
            {
              Nonterminal RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		String id1 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int declarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nonterminal declar = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id2 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    if(!id1.equalsIgnoreCase(id2)){
        throw new SemanticException("Module name mismatched!");
    }
    RESULT = new Nonterminal();
    RESULT.complexity = declar.complexity;
    res = RESULT.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("module",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= module EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal start_val = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // module ::= MODULE IDENTIFIER SEMI declarations BEGIN statement_sequence END IDENTIFIER DOT 
            {
              Nonterminal RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		String id1 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int declarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Nonterminal declar = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id2 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    if(!id1.equalsIgnoreCase(id2)){
        throw new SemanticException("Module name mismatched!");
    }
    RESULT = new Nonterminal();
    RESULT.complexity = declar.complexity + ss.complexity;
    res = RESULT.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("module",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // declarations ::= const_declare type_declare var_declare procedure_declare 
            {
              Nonterminal RESULT =null;
		int cdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int cdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nonterminal cd = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal td = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int vdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int vdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal vd = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int pdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal pd = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = cd.complexity+td.complexity+vd.complexity+pd.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("declarations",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // const_declare ::= CONST identifier_const 
            {
              Nonterminal RESULT =null;
		int icleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int icright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal ic = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = ic.complexity+5;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("const_declare",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // const_declare ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("const_declare",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // identifier_const ::= identifier_const IDENTIFIER EQUAL expression SEMI 
            {
              Nonterminal RESULT =null;
		int icleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int icright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Nonterminal ic = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Nonterminal();
    if(symbol_list.get(top).containsKey(id)){
        throw new SemanticException("Identifier name has been used!");
    }
    symbol_list.get(top).put(id,e);
    RESULT.complexity = 1+e.complexity+ic.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_const",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // identifier_const ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_const",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // type_declare ::= TYPE identifier_type 
            {
              Nonterminal RESULT =null;
		int itleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int itright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal it = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 10+it.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_declare",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // type_declare ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type_declare",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // identifier_type ::= identifier_type IDENTIFIER EQUAL type SEMI 
            {
              Nonterminal RESULT =null;
		int itleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int itright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Nonterminal it = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Nonterminal();
    t.type.set(0,"type");
    if(symbol_list.get(top).containsKey(id)){
        throw new SemanticException("Identifier name has been used!");
    }
    symbol_list.get(top).put(id,t);
    //System.out.println(id);
    RESULT.complexity = 1+t.complexity+it.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_type",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // identifier_type ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_type",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // var_declare ::= VAR identifier_var 
            {
              Nonterminal RESULT =null;
		int ivleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ivright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal iv = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = iv.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("var_declare",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // var_declare ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("var_declare",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // identifier_var ::= identifier_var identifier_list COLON type SEMI 
            {
              Nonterminal RESULT =null;
		int ivleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int ivright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Nonterminal iv = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Selector il = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Nonterminal();
    String[] i_list = il.value.split(" ");
    /**/
    for(int i = 0;i<i_list.length;i++){
        if(symbol_list.get(top).containsKey(i_list[i])){
            throw new SemanticException("Identifier name has been used!");
        }
        symbol_list.get(top).put(i_list[i],t);
    }
    RESULT.complexity = il.complexity + t.complexity + iv.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_var",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // identifier_var ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_var",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // procedure_declare ::= procedure_declare procedure_declaration SEMI 
            {
              Nonterminal RESULT =null;
		int pd2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int pd2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal pd2 = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int pd1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int pd1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal pd1 = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = pd1.complexity + pd2.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_declare",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // procedure_declare ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_declare",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // procedure_declaration ::= procedure_heading SEMI procedure_body 
            {
              Nonterminal RESULT =null;
		int phleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int phright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Procedure ph = (Procedure)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int pbleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pbright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Procedure pb = (Procedure)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    if(!ph.name.equalsIgnoreCase(pb.name)){
        throw new SemanticException("Procedure name isn't matched");
    }
    RESULT.complexity = ph.complexity + pb.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // procedure_body ::= declarations END IDENTIFIER 
            {
              Procedure RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal declar = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Procedure();
    symbol_list.remove(top);
    top = top-1;
    RESULT.name = id;
    RESULT.complexity = declar.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_body",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // procedure_body ::= declarations BEGIN statement_sequence END IDENTIFIER 
            {
              Procedure RESULT =null;
		int declarleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int declarright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Nonterminal declar = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Procedure();
    symbol_list.remove(top);
    top = top-1;
    RESULT.name = id;
    RESULT.complexity = declar.complexity + ss.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_body",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // procedure_heading ::= PROCEDURE IDENTIFIER 
            {
              Procedure RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Procedure();
    /**/
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.para = new ArrayList<Type>();
    pre.type.add("procedure");
    if(symbol_list.get(top).containsKey(id)){
        throw new SemanticException("Identifier name has been used!");
    }
    symbol_list.get(top).put(id,pre);
    //System.out.println("succeed!");
    HashMap<String,Type> base = new HashMap<String,Type>();
    symbol_list.add(base);
    top = top+1;
    RESULT.name = id;
    RESULT.complexity = 20;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // procedure_heading ::= PROCEDURE IDENTIFIER formal_parameters 
            {
              Procedure RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter fp = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Procedure();
    /**/
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.type.add("procedure");
    pre.para = fp.para;
    if(symbol_list.get(top).containsKey(id)){
        throw new SemanticException("Identifier name has been used!");
    }
    symbol_list.get(top).put(id,pre);
    //System.out.println("succeed!");
    HashMap<String,Type> base = new HashMap<String,Type>();
    symbol_list.add(base);
    top = top+1;
    RESULT.name = id;
    RESULT.complexity = 20 + fp.complexity;
    /**/
    int num = fp.para.size();
    for(int i = 0;i<num;i++){
        String name = fp.var.get(i);
        Type t = fp.para.get(i);
        if(symbol_list.get(top).containsKey(name)){
            throw new SemanticException("Identifier name has been used!");
        }
        symbol_list.get(top).put(name,t);
    }
    

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // formal_parameters ::= LPATH RPATH 
            {
              Parameter RESULT =null;
		
    RESULT = new Parameter();
    RESULT.para = new ArrayList<Type>();
    RESULT.var = new ArrayList<String>();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // formal_parameters ::= LPATH 
            {
              Parameter RESULT =null;
		
    if(true)
        throw new MissingRightParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // formal_parameters ::= RPATH 
            {
              Parameter RESULT =null;
		
    if(true)
        throw new MissingLeftParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // formal_parameters ::= LPATH fp_section optional_fp RPATH 
            {
              Parameter RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Parameter fs = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ofpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ofpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter ofp = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Parameter();
    RESULT.complexity = fs.complexity + ofp.complexity;
    /*,*/
    for(int i = 0;i<fs.var.size();i++){
        String pre = fs.var.get(i);
        if(ofp.var.contains(pre)){
            throw new SemanticException("Identifier name has been used!");
        }
    }
    fs.var.addAll(ofp.var);
    fs.para.addAll(ofp.para);
    RESULT.var = fs.var;
    RESULT.para = fs.para;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // formal_parameters ::= LPATH fp_section optional_fp 
            {
              Parameter RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter fs = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter ofp = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(true)
        throw new MissingRightParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // formal_parameters ::= fp_section optional_fp RPATH 
            {
              Parameter RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Parameter fs = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ofpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ofpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter ofp = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    if(true)
        throw new MissingLeftParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("formal_parameters",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // optional_fp ::= SEMI fp_section optional_fp 
            {
              Parameter RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter fs = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter ofp = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Parameter();
    RESULT.complexity = fs.complexity + ofp.complexity;
    /*,*/
    for(int i = 0;i<fs.var.size();i++){
        String pre = fs.var.get(i);
        if(ofp.var.contains(pre)){
            throw new SemanticException("Identifier name has been used!");
        }
    }
    fs.var.addAll(ofp.var);
    fs.para.addAll(ofp.para);
    RESULT.var = fs.var;
    RESULT.para = fs.para;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_fp",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // optional_fp ::= 
            {
              Parameter RESULT =null;
		
    RESULT = new Parameter();
    RESULT.para = new ArrayList<Type>();
    RESULT.var = new ArrayList<String>();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_fp",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // fp_section ::= identifier_list COLON type 
            {
              Parameter RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Selector il = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Parameter();
    RESULT.para = new ArrayList<Type>();
    RESULT.var = new ArrayList<String>();
    String[] i_list = il.value.split(" ");
    for(int i = 0;i<i_list.length;i++){
        if(!RESULT.var.contains(i_list[i])){
            RESULT.para.add(t);
            RESULT.var.add(i_list[i]);
        }
        else{
            throw new SemanticException("Identifier name has been used!");
        }
    }
    RESULT.complexity = il.complexity + t.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("fp_section",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // fp_section ::= VAR identifier_list COLON type 
            {
              Parameter RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Selector il = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Parameter();
    RESULT.para = new ArrayList<Type>();
    RESULT.var = new ArrayList<String>();
    t.left = true;
    String[] i_list = il.value.split(" ");
    for(int i = 0;i<i_list.length;i++){
        if(!RESULT.var.contains(i_list[i])){
            RESULT.para.add(t);
            RESULT.var.add(i_list[i]);
        }
        else{
            throw new SemanticException("Identifier name has been used!");
        }
    }
    RESULT.complexity = il.complexity + t.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("fp_section",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // type ::= IDENTIFIER 
            {
              Type RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    int pos = -1;
    for(int i = top;i>=0;i--){
        if(symbol_list.get(i).containsKey(id)){
            pos = i;
            break;
        }
    }
    if(pos==-1){
        throw new SemanticException("Identifier hasn't been declared");
    }
    Type pre = symbol_list.get(pos).get(id);
    if(!pre.type.get(0).equalsIgnoreCase("type")){
        throw new SemanticException("This identifier isn't a type");
    }
    Type p = new Type();
    p.type = new ArrayList<String>();
    p.type.add("calculate");
    p.type.add(pre.type.get(1));
    p.symbol_list = pre.symbol_list;
    p.arr_type = pre.arr_type;
    p.para = pre.para;
    RESULT = p;
    RESULT.complexity = 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // type ::= array_type 
            {
              Type RESULT =null;
		int atleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int atright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Arr at = (Arr)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.arr_type = at.base_type;
    pre.type.add("calculate");
    pre.type.add("array");
    pre.complexity = at.complexity+8;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // type ::= record_type 
            {
              Type RESULT =null;
		int rtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Rec rt = (Rec)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.type.add("calculate");
    pre.type.add("record");
    pre.symbol_list = rt.symbol_list;
    pre.complexity = rt.complexity+3;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // type ::= INTEGER 
            {
              Type RESULT =null;
		
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.type.add("calculate");
    pre.type.add("integer");
    pre.complexity = 1;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // type ::= BOOLEAN 
            {
              Type RESULT =null;
		
    Type pre = new Type();
    pre.type = new ArrayList<String>();
    pre.type.add("calculate");
    pre.type.add("boolean");
    pre.complexity = 1;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("type",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // record_type ::= RECORD field_list optional_field END 
            {
              Rec RESULT =null;
		int flleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int flright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Rec fl = (Rec)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opfleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opfright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Rec opf = (Rec)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    Rec pre = new Rec();
    HashMap<String,Type> list1 = fl.symbol_list;
    HashMap<String,Type> list2 = opf.symbol_list;
    /**/
    Set<String> key = list1.keySet();
    
    for(String s:key){
        if(list2.containsKey(s)){
            throw new SemanticException("Identifier name has been used!");
        }
    }
    list1.putAll(list2);
    pre.symbol_list = list1;
    pre.complexity = fl.complexity + opf.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("record_type",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // optional_field ::= SEMI field_list optional_field 
            {
              Rec RESULT =null;
		int flleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int flright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Rec fl = (Rec)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int opfleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opfright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Rec opf = (Rec)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Rec pre = new Rec();
    HashMap<String,Type> list1 = fl.symbol_list;
    HashMap<String,Type> list2 = opf.symbol_list;
    /**/
    Set<String> key = list1.keySet();
    for(String s:key){
        if(list2.containsKey(s)){
            throw new SemanticException("Identifier name has been used!");
        }
    }
    list1.putAll(list2);
    pre.symbol_list = list1;
    pre.complexity = fl.complexity + opf.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_field",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // optional_field ::= 
            {
              Rec RESULT =null;
		
    Rec pre = new Rec();
    pre.symbol_list = new HashMap<String,Type>();
    pre.complexity = 0;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_field",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // field_list ::= identifier_list COLON type 
            {
              Rec RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Selector il = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  
    Rec pre = new Rec();
    pre.symbol_list = new HashMap<String,Type>();
    String[] i_list = il.value.split(" ");
    for(int i = 0;i<i_list.length;i++){
        if(!pre.symbol_list.containsKey(i_list[i])){
            pre.symbol_list.put(i_list[i],t);
        }
        else{
            throw new SemanticException("Identifier name has been used!");
        }
    }
    pre.complexity = il.complexity + t.complexity;
    RESULT = pre;
    //System.out.println(il.value);

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_list",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // field_list ::= 
            {
              Rec RESULT =null;
		
    Rec pre = new Rec();
    pre.symbol_list = new HashMap<String,Type>();
    pre.complexity = 0;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("field_list",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // array_type ::= ARRAY expression OF type 
            {
              Arr RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Arr pre = new Arr();
    if(!e.type.get(0).equalsIgnoreCase("calculate")||!e.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    pre.base_type = t;
    pre.complexity = e.complexity + t.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("array_type",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // identifier_list ::= IDENTIFIER optional_identifier 
            {
              Selector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int oileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oiright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Selector oi = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    String pre = id + " " + oi.value;
    oi.value = pre;
    RESULT = oi;
    RESULT.complexity += 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("identifier_list",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // optional_identifier ::= COMMA IDENTIFIER optional_identifier 
            {
              Selector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int oileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oiright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Selector oi = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    String pre = id + " " + oi.value;
    oi.value = pre;
    RESULT = oi;
    RESULT.complexity += 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_identifier",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // optional_identifier ::= 
            {
              Selector RESULT =null;
		
    Selector pre = new Selector();
    pre.complexity = 0;
    pre.value = "";
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_identifier",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // statement_sequence ::= statement optional_statement 
            {
              Nonterminal RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal s = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int osleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int osright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal os = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = s.complexity + os.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // optional_statement ::= SEMI statement optional_statement 
            {
              Nonterminal RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal s = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int osleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int osright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal os = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = s.complexity + os.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_statement",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // optional_statement ::= 
            {
              Nonterminal RESULT =null;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = 0;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_statement",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // statement ::= assignment 
            {
              Nonterminal RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal a = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    /**/
    Nonterminal pre = new Nonterminal();
    pre.complexity = a.complexity * (if_level+1) * (int)Math.pow(2,while_level);
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // statement ::= procedure_call 
            {
              Nonterminal RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal p = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    /**/
    Nonterminal pre = new Nonterminal();
    pre.complexity = p.complexity * (if_level+1) * (int)Math.pow(2,while_level);
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // statement ::= if_statement 
            {
              Nonterminal RESULT =null;
		int isleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int isright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal is = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = is.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // statement ::= while_statement 
            {
              Nonterminal RESULT =null;
		int wsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int wsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal ws = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = ws.complexity;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // statement ::= 
            {
              Nonterminal RESULT =null;
		
    Nonterminal pre = new Nonterminal();
    pre.complexity = 0;
    RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("statement",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // while_statement ::= WHILE M expression DO statement_sequence END 
            {
              Nonterminal RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    
    if(!e.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT = new Nonterminal();
    RESULT.complexity += e.complexity*(if_level+1) * (int)Math.pow(2,while_level) + ss.complexity;
    while_level -= 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("while_statement",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // M ::= 
            {
              Object RESULT =null;
		
    while_level += 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // if_statement ::= IF N expression THEN statement_sequence elsif_statement else_statement END 
            {
              Nonterminal RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal els = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int esleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int esright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal es = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Nonterminal();
    if(!e.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity += e.complexity*(if_level+1) * (int)Math.pow(2,while_level) + ss.complexity + els.complexity + es.complexity;
    if_level -= 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("if_statement",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // N ::= 
            {
              Object RESULT =null;
		
    if_level += 1;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("N",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // elsif_statement ::= ELSIF expression THEN statement_sequence elsif_statement 
            {
              Nonterminal RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal els = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    if(!e.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = e.complexity*(if_level+1) * (int)Math.pow(2,while_level) + ss.complexity + els.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elsif_statement",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // elsif_statement ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("elsif_statement",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // else_statement ::= ELSE statement_sequence 
            {
              Nonterminal RESULT =null;
		int ssleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nonterminal ss = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Nonterminal();
    RESULT.complexity = ss.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("else_statement",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // else_statement ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("else_statement",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // procedure_call ::= IDENTIFIER 
            {
              Nonterminal RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(id.equalsIgnoreCase("read")||id.equalsIgnoreCase("write")||id.equalsIgnoreCase("writeln")){
        Nonterminal pre = new Nonterminal();
        pre.complexity = 8;
        RESULT = pre;
    }
    else{
        Nonterminal pre = new Nonterminal();
        int pos = -1;
        for(int i = top;i>=0;i--){
            if(symbol_list.get(i).containsKey(id)){
                pos = i;
                break;
            }
        }
        if(pos==-1){
            throw new SemanticException("Identifier isn't been declared!");
        }
        Type t = symbol_list.get(pos).get(id);
        if(!t.type.get(0).equalsIgnoreCase("procedure")){
            throw new TypeMismatchedException();
        }
        pre.complexity = 8;
        RESULT = pre;
    }
    

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_call",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // procedure_call ::= IDENTIFIER actual_parameters 
            {
              Nonterminal RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int apleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter ap = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(id.equalsIgnoreCase("read")||id.equalsIgnoreCase("write")||id.equalsIgnoreCase("writeln")){
        Nonterminal pre = new Nonterminal();
        pre.complexity = 8+ap.complexity;
        RESULT = pre;
    }
    else{
        Nonterminal pre = new Nonterminal();
        int pos = -1;
        for(int i = top;i>=0;i--){
            if(symbol_list.get(i).containsKey(id)){
                pos = i;
                break;
            }
        }
        if(pos==-1){
            throw new SemanticException("Identifier isn't been declared!");
        }
        Type t = symbol_list.get(pos).get(id);
        if(!t.type.get(0).equalsIgnoreCase("procedure")){
            throw new TypeMismatchedException();
        }
        List<Type> para1 = t.para;
        List<Type> para2 = ap.para;
        if(para1.size()!=para2.size()){
            throw new ParameterMismatchedException();
        }
        for(int i = 0;i<para1.size();i++){
            if(!check_type(para1.get(i),para2.get(i))){
                throw new TypeMismatchedException();
            }
        }
        pre.complexity = 8+ap.complexity;
        RESULT = pre;
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("procedure_call",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // actual_parameters ::= LPATH RPATH 
            {
              Parameter RESULT =null;
		
    RESULT = new Parameter();
    RESULT.complexity = 0;
    RESULT.para = new ArrayList<Type>();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // actual_parameters ::= LPATH 
            {
              Parameter RESULT =null;
		
    if(true)
        throw new MissingRightParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // actual_parameters ::= RPATH 
            {
              Parameter RESULT =null;
		
    if(true)
        throw new MissingLeftParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // actual_parameters ::= LPATH expression optional_expression RPATH 
            {
              Parameter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int oeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int oeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter oe = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = new Parameter();
    RESULT.complexity = e.complexity + oe.complexity;
    RESULT.para = new ArrayList<Type>();
    RESULT.para.add(e);
    RESULT.para.addAll(oe.para);

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // actual_parameters ::= LPATH expression optional_expression 
            {
              Parameter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int oeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter oe = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(true)
        throw new MissingRightParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // actual_parameters ::= expression optional_expression RPATH 
            {
              Parameter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int oeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int oeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Parameter oe = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    if(true)
        throw new MissingLeftParenthesisException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("actual_parameters",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // optional_expression ::= COMMA expression optional_expression 
            {
              Parameter RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int oeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Parameter oe = (Parameter)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Parameter();
    RESULT.complexity = e.complexity + oe.complexity;
    RESULT.para = new ArrayList<Type>();
    RESULT.para.add(e);
    RESULT.para.addAll(oe.para);

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_expression",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // optional_expression ::= 
            {
              Parameter RESULT =null;
		
    RESULT = new Parameter();
    RESULT.complexity = 0;
    RESULT.para = new ArrayList<Type>();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_expression",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // assignment ::= IDENTIFIER selector ASSIGN expression 
            {
              Nonterminal RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Selector s = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		  
    int pos = -1;
    for(int i = top;i>=0;i--){
        if(symbol_list.get(i).containsKey(id)){
            pos = i;
            break;
        }
    }
    if(pos==-1){
        throw new SemanticException("Identifier isn't been declared!");
    }
    Type pre = symbol_list.get(pos).get(id);
    String select = s.value;
    /*selectortype*/
    Type after = select_field(pre,select);
    if(after==null||!check_type(after,e)){
        throw new TypeMismatchedException();
    }
    RESULT = new Nonterminal();
    RESULT.complexity = s.complexity + e.complexity + 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("assignment",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // expression ::= simple_expression 
            {
              Type RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type se = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = se;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // expression ::= simple_expression relaop simple_expression 
            {
              Type RESULT =null;
		int se1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int se1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Type se1 = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int se2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int se2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type se2 = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!se1.type.get(1).equalsIgnoreCase("integer")||!se2.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = se1.complexity + se2.complexity + 4;
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("boolean");

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("expression",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // relaop ::= EQUAL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // relaop ::= NEQUAL 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // relaop ::= LESS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // relaop ::= ELESS 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // relaop ::= MORE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // relaop ::= EMORE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("relaop",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // simple_expression ::= sign term optional_term 
            {
              Type RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nonterminal s = (Nonterminal)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int otleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int otright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type ot = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(ot.type.size()==0){
        RESULT = t;
        RESULT.complexity += s.complexity;
    }
    else{
        RESULT = new Type();
        if(ot.type.size()>1&&!t.type.get(1).equalsIgnoreCase(ot.type.get(1))){
            throw new TypeMismatchedException();
        }
        RESULT.complexity = t.complexity + ot.complexity + s.complexity;
        RESULT.type = new ArrayList<String>();
        RESULT.type.add("calculate");
        RESULT.type.add(t.type.get(1));
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("simple_expression",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sign ::= ADD 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sign",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sign ::= MINUS 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sign",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sign ::= 
            {
              Nonterminal RESULT =null;
		
    RESULT = new Nonterminal();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("sign",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // optional_term ::= ADD term optional_term 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int otleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int otright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type ot = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!t.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    if(ot.type.size()>1&&!ot.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");
    RESULT.complexity = t.complexity + ot.complexity + 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_term",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // optional_term ::= MINUS term optional_term 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int otleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int otright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type ot = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!t.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    if(ot.type.size()>1&&!ot.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");
    RESULT.complexity = t.complexity + ot.complexity + 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_term",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // optional_term ::= OR term optional_term 
            {
              Type RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type t = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int otleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int otright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type ot = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!t.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    if(ot.type.size()>1&&!ot.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("boolean");
    RESULT.complexity = t.complexity + ot.complexity + 6;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_term",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // optional_term ::= 
            {
              Type RESULT =null;
		
    RESULT = new Type();
    RESULT.type = new ArrayList<String>();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_term",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // term ::= factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(of.type.size()==0){
        RESULT = f;
    }
    else{
        RESULT = new Type();
        if(of.type.size()>1&&!f.type.get(1).equalsIgnoreCase(of.type.get(1))){
            throw new TypeMismatchedException();
        }
        RESULT.complexity = f.complexity + of.complexity;
        RESULT.type = new ArrayList<String>();
        RESULT.type.add("calculate");
        RESULT.type.add(f.type.get(1));
    }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // optional_factor ::= MUL factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!f.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    if(of.type.size()>1&&!of.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = f.complexity + of.complexity + 4;
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // optional_factor ::= DIV factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!f.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    if(of.type.size()>1&&!of.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = f.complexity + of.complexity + 4;
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // optional_factor ::= MOD factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!f.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    if(of.type.size()>1&&!of.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = f.complexity + of.complexity + 4;
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // optional_factor ::= AND factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    RESULT = new Type();
    if(!f.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    if(of.type.size()>1&&!of.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = f.complexity + of.complexity + 6;
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("boolean");

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // optional_factor ::= factor optional_factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ofleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ofright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type of = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(true)
        throw new MissingOperatorException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // optional_factor ::= 
            {
              Type RESULT =null;
		
    RESULT = new Type();
    RESULT.type = new ArrayList<String>();
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("optional_factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // factor ::= IDENTIFIER selector 
            {
              Type RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Selector s = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    int pos = -1;
    for(int i = top;i>=0;i--){
        if(symbol_list.get(i).containsKey(id)){
            pos = i;
            break;
        }
    }
    if(pos==-1){
        throw new SemanticException("The identifier hasn't been declared");
    }
    Type pre = symbol_list.get(pos).get(id);
    if(pre.type.get(0).equalsIgnoreCase("procedure")){
        throw new TypeMismatchedException();
    }
    RESULT = new Type();
    Type after = select_field(pre,s.value);
    if(after == null){
        throw new TypeMismatchedException();
    }
    RESULT.complexity = s.complexity;
    RESULT.type = after.type;
    RESULT.symbol_list = after.symbol_list;
    RESULT.arr_type = after.arr_type;
    RESULT.para = after.para;
    RESULT.left = true;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // factor ::= DIGIT 
            {
              Type RESULT =null;
		
    RESULT = new Type();
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("integer");
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // factor ::= LPATH expression RPATH 
            {
              Type RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
    RESULT = e;
    RESULT.complexity+=6;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // factor ::= LPATH RPATH 
            {
              Type RESULT =null;
		
    if(true)
        throw new MissingOperandException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // factor ::= NOT factor 
            {
              Type RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Type f = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(!f.type.get(1).equalsIgnoreCase("boolean")){
        throw new TypeMismatchedException();
    }
    RESULT = new Type();
    RESULT.type = new ArrayList<String>();
    RESULT.type.add("calculate");
    RESULT.type.add("boolean");
    RESULT.complexity = f.complexity + 6;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // factor ::= 
            {
              Type RESULT =null;
		
    if(true)
        throw new MissingOperandException();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("factor",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // selector ::= DOT IDENTIFIER selector 
            {
              Selector RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Selector s = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    s.value = "." + id + s.value;
    RESULT = s;
    RESULT.complexity += 2;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("selector",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // selector ::= LBRACK expression RBRACK selector 
            {
              Selector RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Type e = (Type)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Selector s = (Selector)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
    if(!e.type.get(1).equalsIgnoreCase("integer")){
        throw new TypeMismatchedException();
    }
    s.value = "[]"+s.value;
    RESULT = s;
    RESULT.complexity += 2+e.complexity;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("selector",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // selector ::= 
            {
              Selector RESULT =null;
		
    RESULT = new Selector();
    RESULT.value = "";
    RESULT.complexity = 0;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("selector",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
